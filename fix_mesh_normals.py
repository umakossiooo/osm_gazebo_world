#!/usr/bin/env python3
"""
Fix OBJ mesh files generated by OSM2World by calculating and adding missing vertex normals.
This resolves the 'normal count [0] that matches its vertex count' errors in Gazebo.
"""

import argparse
import math
import os
import sys
from pathlib import Path
from typing import List, Tuple, Dict


def calculate_face_normal(v1: Tuple[float, float, float], 
                         v2: Tuple[float, float, float], 
                         v3: Tuple[float, float, float]) -> Tuple[float, float, float]:
    """Calculate face normal using cross product of two edge vectors."""
    # Edge vectors
    edge1 = (v2[0] - v1[0], v2[1] - v1[1], v2[2] - v1[2])
    edge2 = (v3[0] - v1[0], v3[1] - v1[1], v3[2] - v1[2])
    
    # Cross product
    nx = edge1[1] * edge2[2] - edge1[2] * edge2[1]
    ny = edge1[2] * edge2[0] - edge1[0] * edge2[2]
    nz = edge1[0] * edge2[1] - edge1[1] * edge2[0]
    
    # Normalize
    length = math.sqrt(nx*nx + ny*ny + nz*nz)
    if length > 0:
        return (nx/length, ny/length, nz/length)
    else:
        return (0.0, 0.0, 1.0)  # Default upward normal


def normalize_vector(v: Tuple[float, float, float]) -> Tuple[float, float, float]:
    """Normalize a vector to unit length."""
    length = math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2])
    if length > 0:
        return (v[0]/length, v[1]/length, v[2]/length)
    else:
        return (0.0, 0.0, 1.0)


def add_vectors(v1: Tuple[float, float, float], 
               v2: Tuple[float, float, float]) -> Tuple[float, float, float]:
    """Add two vectors."""
    return (v1[0] + v2[0], v1[1] + v2[1], v1[2] + v2[2])


def fix_obj_normals(input_path: Path, output_path: Path) -> None:
    """
    Read an OBJ file, calculate vertex normals, and write a fixed version.
    """
    print(f"Processing: {input_path}")
    
    vertices = []  # List of (x, y, z) tuples
    faces = []     # List of face data: [(v1_idx, v2_idx, v3_idx), ...]
    other_lines = []  # Non-vertex, non-face lines to preserve
    
    # Parse the OBJ file
    with open(input_path, 'r') as f:
        for line_num, line in enumerate(f, 1):
            line = line.strip()
            if not line or line.startswith('#'):
                other_lines.append(line)
                continue
                
            parts = line.split()
            if not parts:
                other_lines.append(line)
                continue
                
            if parts[0] == 'v':  # Vertex
                if len(parts) >= 4:
                    try:
                        x, y, z = float(parts[1]), float(parts[2]), float(parts[3])
                        vertices.append((x, y, z))
                    except ValueError:
                        print(f"Warning: Invalid vertex on line {line_num}: {line}")
                        other_lines.append(line)
                else:
                    print(f"Warning: Incomplete vertex on line {line_num}: {line}")
                    other_lines.append(line)
                    
            elif parts[0] == 'f':  # Face
                # Handle different face formats (with/without texture/normal indices)
                face_vertices = []
                for vertex_ref in parts[1:]:
                    # Handle formats: "v", "v/vt", "v/vt/vn", "v//vn"
                    vertex_idx = int(vertex_ref.split('/')[0])
                    # Convert from 1-based to 0-based indexing
                    face_vertices.append(vertex_idx - 1)
                
                if len(face_vertices) >= 3:
                    # For triangular faces, add directly
                    if len(face_vertices) == 3:
                        faces.append(tuple(face_vertices))
                    else:
                        # For polygons, triangulate (simple fan triangulation)
                        for i in range(1, len(face_vertices) - 1):
                            faces.append((face_vertices[0], face_vertices[i], face_vertices[i+1]))
                else:
                    print(f"Warning: Invalid face on line {line_num}: {line}")
                    
            else:
                other_lines.append(line)
    
    if not vertices:
        print("Warning: No vertices found in the mesh")
        return
        
    if not faces:
        print("Warning: No faces found in the mesh")
        return
    
    print(f"Found {len(vertices)} vertices and {len(faces)} faces")
    
    # Calculate vertex normals by averaging face normals
    vertex_normals = [(0.0, 0.0, 0.0)] * len(vertices)
    vertex_face_count = [0] * len(vertices)
    
    for face in faces:
        if len(face) >= 3:
            v1_idx, v2_idx, v3_idx = face[0], face[1], face[2]
            
            # Check bounds
            if (0 <= v1_idx < len(vertices) and 
                0 <= v2_idx < len(vertices) and 
                0 <= v3_idx < len(vertices)):
                
                v1, v2, v3 = vertices[v1_idx], vertices[v2_idx], vertices[v3_idx]
                face_normal = calculate_face_normal(v1, v2, v3)
                
                # Add face normal to each vertex of the face
                for vertex_idx in face:
                    if 0 <= vertex_idx < len(vertices):
                        vertex_normals[vertex_idx] = add_vectors(vertex_normals[vertex_idx], face_normal)
                        vertex_face_count[vertex_idx] += 1
    
    # Normalize the accumulated normals
    for i in range(len(vertex_normals)):
        if vertex_face_count[i] > 0:
            # Average the accumulated normals
            normal = vertex_normals[i]
            avg_normal = (normal[0] / vertex_face_count[i], 
                         normal[1] / vertex_face_count[i], 
                         normal[2] / vertex_face_count[i])
            vertex_normals[i] = normalize_vector(avg_normal)
        else:
            vertex_normals[i] = (0.0, 0.0, 1.0)  # Default upward normal
    
    print(f"Generated {len(vertex_normals)} vertex normals")
    
    # Write the fixed OBJ file
    output_path.parent.mkdir(parents=True, exist_ok=True)
    
    with open(output_path, 'w') as f:
        # Write header comment
        f.write("# OBJ file fixed by fix_mesh_normals.py\n")
        f.write("# Vertex normals calculated from face geometry\n\n")
        
        # Write preserved lines (materials, groups, etc.) that came before vertices
        for line in other_lines:
            if not line.startswith('g ') and not line.startswith('usemtl '):
                f.write(f"{line}\n")
        
        # Write vertices
        for vertex in vertices:
            f.write(f"v {vertex[0]} {vertex[1]} {vertex[2]}\n")
        
        # Write vertex normals
        for normal in vertex_normals:
            f.write(f"vn {normal[0]} {normal[1]} {normal[2]}\n")
        
        f.write("\n")
        
        # Write group/material lines
        for line in other_lines:
            if line.startswith('g ') or line.startswith('usemtl '):
                f.write(f"{line}\n")
        
        # Write faces with normal references
        face_idx = 0
        with open(input_path, 'r') as orig_f:
            for line in orig_f:
                line = line.strip()
                if line.startswith('f '):
                    parts = line.split()
                    new_face_parts = ['f']
                    
                    for vertex_ref in parts[1:]:
                        # Parse original vertex reference
                        vertex_parts = vertex_ref.split('/')
                        vertex_idx = vertex_parts[0]
                        
                        if len(vertex_parts) == 1:
                            # Format: v -> v//vn
                            new_face_parts.append(f"{vertex_idx}//{vertex_idx}")
                        elif len(vertex_parts) == 2:
                            # Format: v/vt -> v/vt/vn
                            texture_idx = vertex_parts[1] if vertex_parts[1] else ""
                            new_face_parts.append(f"{vertex_idx}/{texture_idx}/{vertex_idx}")
                        elif len(vertex_parts) == 3:
                            # Format: v/vt/vn -> v/vt/vn (replace normal)
                            texture_idx = vertex_parts[1] if vertex_parts[1] else ""
                            new_face_parts.append(f"{vertex_idx}/{texture_idx}/{vertex_idx}")
                    
                    f.write(" ".join(new_face_parts) + "\n")
    
    print(f"Fixed OBJ file written to: {output_path}")


def main():
    parser = argparse.ArgumentParser(
        description="Fix OBJ mesh files by adding calculated vertex normals"
    )
    parser.add_argument("input", help="Input OBJ file path")
    parser.add_argument("-o", "--output", help="Output OBJ file path (default: input_fixed.obj)")
    
    args = parser.parse_args()
    
    input_path = Path(args.input)
    if not input_path.exists():
        print(f"Error: Input file not found: {input_path}")
        return 1
    
    if args.output:
        output_path = Path(args.output)
    else:
        output_path = input_path.parent / f"{input_path.stem}_fixed{input_path.suffix}"
    
    try:
        fix_obj_normals(input_path, output_path)
        print("Success: Mesh normals fixed!")
        return 0
    except Exception as e:
        print(f"Error fixing mesh normals: {e}")
        return 1


if __name__ == "__main__":
    sys.exit(main())